package watch_test

import (
	"os"
	"path/filepath"
	"sync/atomic"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/housecat-inc/cheetah/pkg/watch"
)

func TestMatchesAny(t *testing.T) {
	tests := []struct {
		_name    string
		path     string
		patterns []string
		out      bool
	}{
		{
			_name:    "matches base name",
			path:     "src/main.go",
			patterns: []string{"*.go"},
			out:      true,
		},
		{
			_name:    "matches full path",
			path:     "src/main.go",
			patterns: []string{"src/*"},
			out:      true,
		},
		{
			_name:    "no match",
			path:     "src/main.go",
			patterns: []string{"*.js"},
			out:      false,
		},
		{
			_name:    "empty patterns",
			path:     "src/main.go",
			patterns: []string{},
			out:      false,
		},
		{
			_name:    "multiple patterns first matches",
			path:     "style.css",
			patterns: []string{"*.css", "*.js"},
			out:      true,
		},
		{
			_name:    "multiple patterns second matches",
			path:     "app.js",
			patterns: []string{"*.css", "*.js"},
			out:      true,
		},
	}

	for _, tt := range tests {
		t.Run(tt._name, func(t *testing.T) {
			a := assert.New(t)
			out := watch.MatchesAny(tt.path, tt.patterns)
			a.Equal(tt.out, out)
		})
	}
}

func TestScan(t *testing.T) {
	a := assert.New(t)
	r := require.New(t)

	dir := t.TempDir()
	r.NoError(os.MkdirAll(filepath.Join(dir, "src"), 0o755))
	r.NoError(os.WriteFile(filepath.Join(dir, "src", "main.go"), []byte("package main"), 0o644))
	r.NoError(os.WriteFile(filepath.Join(dir, "src", "style.css"), []byte("body{}"), 0o644))
	r.NoError(os.WriteFile(filepath.Join(dir, "README.md"), []byte("# hi"), 0o644))

	tests := []struct {
		_name          string
		patterns       []string
		ignorePatterns []string
		out            int
	}{
		{
			_name: "all files",
			out:   3,
		},
		{
			_name:    "filter by pattern",
			patterns: []string{"*.go"},
			out:      1,
		},
		{
			_name:          "ignore pattern",
			ignorePatterns: []string{"*.css"},
			out:            2,
		},
		{
			_name:          "pattern and ignore",
			patterns:       []string{"*.go", "*.css"},
			ignorePatterns: []string{"*.css"},
			out:            1,
		},
	}

	for _, tt := range tests {
		t.Run(tt._name, func(t *testing.T) {
			w := watch.New(dir, tt.patterns, tt.ignorePatterns, func(string) {})
			files := w.Scan()
			a.Equal(tt.out, len(files))
		})
	}
}

func TestScanSkipsDotAndVendorDirs(t *testing.T) {
	a := assert.New(t)
	r := require.New(t)

	dir := t.TempDir()
	r.NoError(os.MkdirAll(filepath.Join(dir, ".git"), 0o755))
	r.NoError(os.WriteFile(filepath.Join(dir, ".git", "config"), []byte(""), 0o644))
	r.NoError(os.MkdirAll(filepath.Join(dir, "node_modules", "pkg"), 0o755))
	r.NoError(os.WriteFile(filepath.Join(dir, "node_modules", "pkg", "index.js"), []byte(""), 0o644))
	r.NoError(os.MkdirAll(filepath.Join(dir, "vendor"), 0o755))
	r.NoError(os.WriteFile(filepath.Join(dir, "vendor", "lib.go"), []byte(""), 0o644))
	r.NoError(os.WriteFile(filepath.Join(dir, "main.go"), []byte("package main"), 0o644))

	w := watch.New(dir, nil, nil, func(string) {})
	files := w.Scan()
	a.Equal(1, len(files))
}

func TestDetectsFileChange(t *testing.T) {
	a := assert.New(t)
	r := require.New(t)

	dir := t.TempDir()
	f := filepath.Join(dir, "main.go")
	r.NoError(os.WriteFile(f, []byte("v1"), 0o644))

	var changed int32
	w := watch.New(dir, []string{"*.go"}, nil, func(path string) {
		atomic.AddInt32(&changed, 1)
	})
	w.Start()
	defer w.Stop()

	time.Sleep(150 * time.Millisecond)
	r.NoError(os.WriteFile(f, []byte("v2"), 0o644))

	a.Eventually(func() bool {
		return atomic.LoadInt32(&changed) > 0
	}, 5*time.Second, 50*time.Millisecond)
}

func TestDetectsFileDelete(t *testing.T) {
	a := assert.New(t)
	r := require.New(t)

	dir := t.TempDir()
	f := filepath.Join(dir, "main.go")
	r.NoError(os.WriteFile(f, []byte("v1"), 0o644))

	var changed int32
	w := watch.New(dir, []string{"*.go"}, nil, func(path string) {
		atomic.AddInt32(&changed, 1)
	})
	w.Start()
	defer w.Stop()

	time.Sleep(150 * time.Millisecond)
	r.NoError(os.Remove(f))

	a.Eventually(func() bool {
		return atomic.LoadInt32(&changed) > 0
	}, 5*time.Second, 50*time.Millisecond)
}

func TestScanIgnoresDoNotEditFiles(t *testing.T) {
	a := assert.New(t)
	r := require.New(t)

	dir := t.TempDir()
	r.NoError(os.WriteFile(filepath.Join(dir, "main.go"), []byte("package main"), 0o644))
	r.NoError(os.WriteFile(filepath.Join(dir, "generated.go"), []byte("// Code generated by foo. DO NOT EDIT.\npackage gen"), 0o644))
	r.NoError(os.WriteFile(filepath.Join(dir, "schema.go"), []byte("// DO NOT EDIT this file\npackage schema"), 0o644))

	w := watch.New(dir, []string{"*.go"}, nil, func(string) {})
	files := w.Scan()
	a.Equal(1, len(files))
}

func TestDoNotEditFileChangeIgnored(t *testing.T) {
	r := require.New(t)

	dir := t.TempDir()
	f := filepath.Join(dir, "generated.go")
	r.NoError(os.WriteFile(f, []byte("// DO NOT EDIT\npackage gen\nv1"), 0o644))

	var changed int32
	w := watch.New(dir, []string{"*.go"}, nil, func(path string) {
		atomic.AddInt32(&changed, 1)
	})
	w.Start()
	defer w.Stop()

	time.Sleep(150 * time.Millisecond)
	r.NoError(os.WriteFile(f, []byte("// DO NOT EDIT\npackage gen\nv2"), 0o644))

	time.Sleep(500 * time.Millisecond)
	assert.New(t).Equal(int32(0), atomic.LoadInt32(&changed))
}

func TestRefreshPicksUpNewFiles(t *testing.T) {
	a := assert.New(t)
	r := require.New(t)

	dir := t.TempDir()
	r.NoError(os.WriteFile(filepath.Join(dir, "main.go"), []byte("package main"), 0o644))

	var lastChanged atomic.Value
	w := watch.New(dir, []string{"*.go"}, nil, func(path string) {
		lastChanged.Store(path)
	})
	w.Start()
	defer w.Stop()

	time.Sleep(150 * time.Millisecond)

	newFile := filepath.Join(dir, "new.go")
	r.NoError(os.WriteFile(newFile, []byte("package main\nv1"), 0o644))

	w.RefreshFileList()

	time.Sleep(150 * time.Millisecond)
	r.NoError(os.WriteFile(newFile, []byte("package main\nv2"), 0o644))

	a.Eventually(func() bool {
		v := lastChanged.Load()
		if v == nil {
			return false
		}
		return v.(string) == newFile
	}, 5*time.Second, 50*time.Millisecond)
}

func TestRefreshForgetsRemovedFiles(t *testing.T) {
	a := assert.New(t)
	r := require.New(t)

	dir := t.TempDir()
	f := filepath.Join(dir, "main.go")
	r.NoError(os.WriteFile(f, []byte("package main"), 0o644))

	w := watch.New(dir, []string{"*.go"}, nil, func(string) {})
	w.Start()
	defer w.Stop()

	files := w.Scan()
	a.Equal(1, len(files))

	r.NoError(os.Remove(f))
	w.RefreshFileList()

	files = w.Scan()
	a.Equal(0, len(files))
}

func TestRefreshForgetsRemovedDirs(t *testing.T) {
	a := assert.New(t)
	r := require.New(t)

	dir := t.TempDir()
	sub := filepath.Join(dir, "pkg")
	r.NoError(os.MkdirAll(sub, 0o755))
	r.NoError(os.WriteFile(filepath.Join(sub, "a.go"), []byte("package pkg"), 0o644))
	r.NoError(os.WriteFile(filepath.Join(sub, "b.go"), []byte("package pkg"), 0o644))
	r.NoError(os.WriteFile(filepath.Join(dir, "main.go"), []byte("package main"), 0o644))

	w := watch.New(dir, []string{"*.go"}, nil, func(string) {})
	w.Start()
	defer w.Stop()

	files := w.Scan()
	a.Equal(3, len(files))

	r.NoError(os.RemoveAll(sub))
	w.RefreshFileList()

	files = w.Scan()
	a.Equal(1, len(files))
}

func TestStopIsGraceful(t *testing.T) {
	a := assert.New(t)

	dir := t.TempDir()
	os.WriteFile(filepath.Join(dir, "f.txt"), []byte("hi"), 0o644)

	w := watch.New(dir, nil, nil, func(string) {})
	w.Start()

	done := make(chan struct{})
	go func() {
		w.Stop()
		close(done)
	}()

	select {
	case <-done:
	case <-time.After(2 * time.Second):
		a.Fail("Stop did not return in time")
	}
}
